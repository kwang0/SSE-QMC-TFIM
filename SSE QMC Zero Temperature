# Stochastic Series Expansion (SSE) Quantum Monte Carlo (QMC) simulation for the
# T = 0 Transverse-Field Ising Model (TFIM)
using Plots

mutable struct Vertex
    position::Int # p propagation position in imaginary time
    operator_type::Int # 0 = site, 1 = bond, 2 = state (not operator), 3 = null
    site::Int # Included to flip states
    vertices_out::Array{Vertex,1} # [left, left1, right, right1]
end

null_vertex = Vertex(0, 3, 0, Vertex[])

function initializeProbabilityTables(J::Array{Float64,2}, h::Array{Float64,1}, N::Int)
    P_c1 = Array{Float64}(N)
    P_c2 = Array{Float64}(N,N)

    M = 2 * abs.(J)
    for i in 1:N
        M[i,i] = h[i]
    end

    P = sum(M,2)
    s = 0.0
    for i in 1:N
        s += P[i]
        P_c1[i] = s
    end
    P_c1 /= s

    for i in 1:N
        s = 0.0
        for j in 1:N
            s += M[i,j]
            P_c2[i,j] = s
        end
        P_c2[i,:] /= s
    end

    return P_c1, P_c2
end

function flipCluster!(α_l::BitArray{1}, operators::Array{Tuple{Int,Int},1}, vertex::Vertex, direction::Int, legs_encountered::Set{Tuple{Int,Int}}, bonds_encountered::Set{Int}, flip::Bool)
    p = vertex.position
    if vertex.operator_type == 2
        if (direction == 3) && flip
            α_l[vertex.site] = !α_l[vertex.site]
        end
    elseif vertex.operator_type == 0
        leg = (p, direction)
        if in(leg, legs_encountered)
            return
        end
        push!(legs_encountered, leg)

        if flip
            operators[p] = (-(operators[p][1] + 1), operators[p][2])
        end
    elseif vertex.operator_type == 1
        if !in(p, bonds_encountered)
            push!(bonds_encountered, p)
            flipCluster!(α_l, operators, vertex.vertices_out[1], 3, legs_encountered, bonds_encountered, flip)
            flipCluster!(α_l, operators, vertex.vertices_out[2], 3, legs_encountered, bonds_encountered, flip)
            flipCluster!(α_l, operators, vertex.vertices_out[3], 1, legs_encountered, bonds_encountered, flip)
            flipCluster!(α_l, operators, vertex.vertices_out[4], 1, legs_encountered, bonds_encountered, flip)
        end
    end
end


# Flips the spins of clusters under the Swendsen-Wang algorithm
function updateClusters!(α_l::BitArray{1}, operators::Array{Tuple{Int,Int},1}, vertex_list::Array{Vertex,1}, leg_set::Set{Tuple{Int,Int}})
    legs_encountered = Set{Tuple{Int,Int}}()
    bonds_encountered = Set{Int}() # Set of positions of bonds encountered
    for leg in leg_set
        if !in(leg, legs_encountered)
            push!(legs_encountered, leg)

            p = leg[1]
            flip = rand(Bool)
            if flip
                operators[p] = (-(operators[p][1] + 1), operators[p][2])
            end

            direction = leg[2]
            next_vertex = vertex_list[p].vertices_out[direction]
            flipCluster!(α_l, operators, next_vertex, 4 - direction, legs_encountered, bonds_encountered, flip)
        end
    end
end

function update!(α_l::BitArray{1}, operators::Array{Tuple{Int,Int},1}, J::Array{Float64,2}, N::Int, m::Int, P_c1::Array{Float64,1}, P_c2::Array{Float64,2}, s::Int)
    α = deepcopy(α_l)

    last_vertex = Array{Vertex}(N)
    for site in 1:N
        last_vertex[site] = Vertex(0, 2, site, [null_vertex, null_vertex, null_vertex, null_vertex])
    end

    vertex_list = Array{Vertex}(2m)
    leg_set = Set{Tuple{Int,Int}}()

    measurement = 0.0

    # Propagate alpha forward in imaginary time
    for p in 1:2m
        # Local/diagonal updates
        if operators[p][1] == -1
            site = operators[p][2]
            α[site] = !α[site] # flip operator
        else
            while true
                i = searchsortedfirst(P_c1, rand())
                j = searchsortedfirst(P_c2[i,:], rand())

                if (i == j) # Adding diagonal site operator
                    operators[p] = (0, i)
                    break
                else
                    if (J[i,j] > 0) && (α[i] == !α[j]) # Antiferromagnetic bond operator
                        operators[p] = (i, j)
                        break
                    elseif (J[i,j] < 0) && (α[i] == α[j]) # Ferromagnetic bond operator
                        operators[p] = (i, j)
                        break
                    end
                end
            end
        end

        # Cluster building
        if operators[p][1] <= 0 # Site operator encountered
            site = operators[p][2]
            vertex = Vertex(p, 0, site, [last_vertex[site], null_vertex, null_vertex, null_vertex])
            vertex_list[p] = vertex
            push!(leg_set, (p, 1)) # Left leg of vertex
            push!(leg_set, (p, 3)) # Right leg of vertex

            # Update previous vertex
            if last_vertex[site].vertices_out[3] == null_vertex
                last_vertex[site].vertices_out[3] = vertex
            else
                last_vertex[site].vertices_out[4] = vertex
            end
            last_vertex[site] = vertex
        else # Bond operator encountered
            site1 = operators[p][1]
            site2 = operators[p][2]
            vertex = Vertex(p, 1, 0, [last_vertex[site1], last_vertex[site2], null_vertex, null_vertex])
            vertex_list[p] = vertex

            # Update previous vertices
            p1 = last_vertex[site1].position
            p2 = last_vertex[site2].position
            if last_vertex[site1].vertices_out[3] == null_vertex
                last_vertex[site1].vertices_out[3] = vertex
            else
                last_vertex[site1].vertices_out[4] = vertex
            end
            if last_vertex[site2].vertices_out[3] == null_vertex
                last_vertex[site2].vertices_out[3] = vertex
            else
                last_vertex[site2].vertices_out[4] = vertex
            end
            last_vertex[site1] = vertex
            last_vertex[site2] = vertex
        end

        # Measuring <Z_1Z_i> correlators in the middle of simulation
        if p == m
            if α[N >> 2] == α[s]
                measurement = 1
            else
                measurement = -1
            end
        end

        # if operators[p][1] == 0
        #     measurement += 1.0
        # end
    end
    updateClusters!(α_l, operators, vertex_list, leg_set) # Off-diagonal updates

    return measurement
end

# function measure(α_l, operators, i)
#     α = deepcopy(α_l)
#     for p in 1:m
#         if operators[p][1] == -1
#             site = operators[p][2]
#             α[site] = !α[site]
#         end
#     end
#
#     if α[1] == α[i]
#         return 1
#     else
#         return -1
#     end
# end

# function check_validity()
#     α = deepcopy(α_l)
#     for p in 1:2m
#         if operators[p][1] == -1
#             site = operators[p][2]
#             α[site] = !α[site] # flip operator
#         elseif operators[p][1] > 0
#             site1 = operators[p][1]
#             site2 = operators[p][2]
#
#             if (J[site1, site2] > 0) && (α[site1] == α[site2])
#                 α1 = α[site1]
#                 α2 = α[site2]
#                 error("($p) AF Bond ($site1, $site2) is acting on same spin ($α1, $α2)")
#             elseif (J[site1, site2] < 0) && (α[site1] != α[site2])
#                 α1 = α[site1]
#                 α2 = α[site2]
#                 error("($p) Ferro Bond ($site1, $site2) is not acting on same spin ($α1, $α2)")
#             elseif (J[site1, site2] == 0)
#                 α1 = α[site1]
#                 α2 = α[site2]
#                 error("($p) Bond ($site1, $site2) exists on non-interacting spins ($α1, $α2)")
#             end
#         end
#     end
# end

steps = 10000
delay = steps/10

N = 20
m = 100


θ = 0.0
κ = 2
J = zeros(Float64, N, N)
for i in 1:N
    for j in i + 1:N
        J[i,j] = sin(θ) * (1.0/(i - j)^κ)
        J[j,i] = J[i,j]
    end
end
h = ones(Float64, N)
h *= cos(θ)

P_c1, P_c2 = initializeProbabilityTables(J, h, N)

avg = Float64[]
err = Float64[]
M = 20

while (m < 50000)
    println("Testing convergence at m = $m")
    # println("Correlator of site $N/2 with site $i")

    temp = zeros(M)
    for j in 1:M
        println("Iteration: $j")

        α_l = BitArray(rand(Bool,N))
        operators = Array{Tuple{Int, Int}}(2m)
        fill!(operators, (0,1))
        tic()
        for k in 1:steps
            measurement = update!(α_l, operators, J, N, m, P_c1, P_c2, 11)
            # check_validity()
            if (k > delay)
                temp[j] += measurement
            end
        end
        toc()
        temp[j] /= (steps - delay)
        println(temp[j])
    end
    push!(avg, mean(temp))
    push!(err, std(temp)/M)
    println(mean(temp))
    println(std(temp)/M)
    m *= 2
end
